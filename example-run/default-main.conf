#!/bin/bash
# Copyright 2010-2012 Thomas Schoebel-Theuer, sponsored by 1&1 Internet AG
#
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
# notice and this notice are preserved.  This file is offered as-is,
# without any warranty.

#####################################################################

## defaults for standalone tests (without modules)

## replay_host_list
##
## Whitespace-separated list of hostnames where blkreplay is run in parallel.
## Each host must be accessible via ssh, without password prompt.
## You may use advanced shell pattern syntax, such as "myhost{17..23}"

replay_host_list="host672 host{675..679}"

## replay_device_list
##
## Whitespace-separated list of devices where blkreplay is run in parallel.
## You may use advanced shell pattern syntax, such as "/dev/drbd{0..3}"
##
## Notice: you will get the CARTESIAN PRODUCT of
## replay_host_list x replay_device_list
## i.e. all devices must occur on each host.
##
## If you need asymmetric combinations, you can omit (comment out)
## replay_device_list and instead denote each individual combination
## by the special syntax
## replay_host_list="host1:/dev/device1 host2:/dev/device2"
## (or similar)

replay_device_list="/dev/dm-{7,9}"

## input_file_list
##
## Whitespace-separated list of *.load.gz files.
## You may use ordinary shell pattern syntax, such
## as "bursts-ultrafine.readwrite.1b.*.load.gz"
## or advanced shell pattern syntax,
## like "bursts-ultrafine.readwrite.1b.{1..9}.load.gz" etc.
##
## If you provide less input files than needed by the cartesian product
## replay_host_list x replay_device_list, the same input files will be
## re-used in a round-robin fashion.
##
## WARNING! running many hosts on a single input file may lead to
## DISTORTIONS, since all load peaks will occur at the same time,
## and the disk seeks / their distances will be duplicated everywhere
## in exactly the same way. As a workaround, see parameter replay_delta below.
##
## WARNING! Mixing fundamentally different loads can lead to
## unintended results! (if you don't know what you are doing)

input_file_list="${base_dir}/../example-load/artificial/bursts-ultrafine.readwrite.1b.1.load.gz"

## output_label
##
## All output files are prefixed with this name.
## Useful for general description of projects etc.

output_label="MYPROJECT"

## output_add_*
##
## When set to 1 or 0, the output filename will (or will not) contain the
## corresponding information.
## Useful for detailed description of your results.
##
## WARNING! disabling the hostname / device can lead to name clashes
## (mutual overwrites) if you start a replay on multiple hosts
## (and/or on multiple devices) in parallel.

output_add_path=1   # the relative path of the leaf directory is added
output_add_host=1   # add hostname where this blkreplay instance is running
output_add_device=1 # add devicename where this blkreplay instance is running
output_add_input=0  # add the input file name

## replay_start
##
## Starting offset in the input file(s), measured in seconds.
## Often this is 0.
## Can be used to "zoom into" any "time window" in the input files
## (when combined with replay_duration)
##
## Notice: this is _uniformly_ for all input files. If you need
## indiviual time windows from each input file, just create specialized
## input files, e.g. using standard Unix tools like head(1) / tail(1) /
## awk(1) / perl / gzip etc.

replay_start=0

## replay_duration
##
## One of the most important parameters, measured in seconds.
##
## Please read the warnings in the documentation about unexpected
## effects of storage virtualization layers, caches etc when this
## parameter is too short.

replay_duration=3600

## replay_delta
##
## As said above, replaying the same input file many times in parallel
## can lead to unintended distortions. Often, you don't have enough
## independent input files to achieve high replay parallelism.
## As a workaround, you may "move on" the time window by the
## distance $replay_delta, i.e. the next host will replay a
## "later" portion of the same input file. Although this is worse
## than having completely independent / uncorrolated input files,
## this is by far better than "common mode".
##
## Warning! please check the length of your input file, whether
## (replay_start + replay_duration + n * replay_delta) fits into
## the total length. Otherwise, your load will be silently lower
## than intended.
##
## Hint: when needed, replay_delta should be as high as possible, in
## order to avoid repetition of the same parts over and over again.

replay_delta=0

## threads
##
## Replay parallelism. Must be between 1 and (almost) 65536.
##
## Typically, the number of threads is limiting the number of
## outstanding IO requests. Many people think "the higher,
## the better". However, beware of hidden overheads.
##
## Higher numbers will not always lead to better throughput:
## some devices / drivers / IO schedulers will even slow down when
## hammered with too many requests in parallel. Some of these
## bottlenecks vary with the kernel version.
##
## In order to approximate real life behaviour, you should consider
## the ACTUAL threading behaviour of your application.
##
## If you have a "fork bomb" like Apache, use a high number of threads.
## Typically, a database like mysql has a rather low number of threads.

threads=512

## cmode
##
## Shorthand for "conflict mode".
## See section about both timely and positionly overlapping
## in the paper, aka "damaged IO".
##
## Following values are possible:
##
## with-conflicts:
##   No countermeasures against damaged IO are taken.
##   This can lead to the highest possible throughput, but your device
##   may behave incorrectly.
##
## with-drop:
##   In case of damaged IO, the conflicting request is just dropped.
##   This will minimize artificial delays, but at the cost of some
##   distortions from missing requests.
##
## with-ordering:
##   In case of damaged IO, the conflicting requests (as well as
##   any later requests) will be delayed until the conflict has gone.
##   This can lead to artificial delays, because all following requests
##   may be delayed as well.

cmode=with-drop

## vmode
##
## Shorthand for "verify mode".
##
## WARNING! switching on verify can lead to serious performance degradation
## (i.e. blkreplay itself may become a bottleneck)
##
## During verify mode, some temporary files
## /tmp/blkreplay.$$/{verify,completion}_table
## are used to store version information about written data.
##
## Depending on the size of the device, this can take considerable space.
## Depending on workingset behaviour, accesses to those temporary files
## can slow down blkreplay considerably (due to additional IO).
##
## Don't use verify mode for benchmarks!
## Use it only for checking / validation!
##
## Following values are possible:
##
## no-overhead:
##   No checks are done. No overhead.
##
## with-verify:
##   Whenver a sector is read which has been written before (some time
##   ago), the sector header is checked for any violations of the
##   storage semantics.
##
## with-final-verify:
##   In addition to with-verify, at the end all touched sector are
##   separately re-read and checked for any mismatches.
##
## with-paranoia:
##   Like with-final-verify, but in addition _all_ written sectors will
##   be _immediately_ re-read and checked.
##   This leads to high distortions of measurements results (because it
##   doubles the IO rates for all writes), but is useful to
##   check the storage semantics even more thoroughly.

vmode=no-overhead

## verbose_script
##
## When set to 1, make shell output more speaking.

verbose_script=0

#####################################################################

## some advanced parameters (experts only)

#replay_out_start=""
#omit_tmp_cleanup=0
#speedup=1.0

#dry_run=0
#fake_io=0
#fan_out=8
#no_dispatcher=0
#bottleneck=0
